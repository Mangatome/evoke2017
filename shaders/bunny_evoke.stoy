uniform vec3  iResolution;          // viewport resolution (in pixels)
uniform float iGlobalTime;          // shader playback time (in seconds)

mat2 rot( in float a ) {
	float c = cos(a),
        s = sin(a);
    return mat2(c, s, -s, c);
}

float sdEllipsoid( in vec2 p, in vec2 r )
{
    return (length( p/r ) - 1.0) * min(r.x,r.y);
}

float rd(vec2 p, float x) {
    p.x=mod(p.x,x);
    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453123);
}

float rand(vec2 p){
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

float noise(vec2 uv, float x) {
    vec2 iuv=floor(uv),
        fuv=smoothstep(0.,1.,fract(uv)),
        oi=vec2(0.,1.);
    float n00=rd(iuv,x),
        n01=rd(iuv+oi.xy,x),
        n10=rd(iuv+oi.yx,x),
        n11=rd(iuv+oi.yy,x);
    return mix(
        mix(n00,n10,fuv.x),
        mix(n01,n11,fuv.x),
        fuv.y);
}

vec3 hsv(vec3 c) {
    vec4 k=vec4(1.,2./3.,1./3.,3.);
    vec3 p=abs(fract(c.xxx+k.xyz)*4.-k.www);
    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	// Constants
	float PI = 3.14159265359;
	float shakeAmpSpeed = 20.;
	float headSize = 1.5;
	float fluffynessH = .2;
	float fluffynessLR = .02;
	float fluffyPeriod = .5;
	vec3 black = vec3(0., 0., 0.);
	vec3 white = vec3(1., 1., 1.);
	vec3 pink = vec3(1., 0.58, 0.75);

	float it = iGlobalTime;
	vec2 uv = fragCoord.xy / iResolution.xy;

    // aspect x
    uv -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    // Timeline
    float tAppearH = smoothstep(0., 5., it);
    float tshakeH = smoothstep(0., 5., it) * smoothstep(28., 20., it);
    float tFluffyH = smoothstep(4., 6., it);
    float tRays = smoothstep(15., 20., it) * smoothstep(35., 33., it);
    float tOffsetH = smoothstep(20., 28., it);
    float tAppearL = smoothstep(28.25, 28.75, it);
    float tAppearR = smoothstep(29.25, 29.75, it);
    float tPink = smoothstep(31., 32., it);
    float tExplode = smoothstep(33., 35., it);
    float tShowRaby = smoothstep(36., 37., it);
    float tHideRaby = smoothstep(38., 39., it);
    float tFadeOut = smoothstep(39.5, 40., it);

    // Scene management
    float scene2 = step(1, tExplode);
    float scene1 = 1 - scene2;

    vec3 rabbitColor = white * scene1 + pink * scene2;
    vec3 earColor = pink * scene1 + white * scene2;

    // Zoom scene
    uv *= 1 - tExplode * 1 + scene2;

    // Pan Daddy
    vec2 rabbitPan = vec2(0., 1.) * tOffsetH;

    // Pan Rabby
    uv += scene2 * mix(vec2(.3, 1.), vec2(.2, .55), tShowRaby - tHideRaby);
    uv = uv * scene1 + uv * rot(PI * -.1) * scene2;

    // Background color
    vec3 c = mix(black, vec3(1., .2, .5), tPink);
    c = mix(c, white, scene2);

    // Rays
    float nr = 400.;
    vec2 uvr = uv + rabbitPan / 10;
    float ruvr = rand(uvr * it);
    float ang=atan(uvr.y,uvr.x)/6.28318531*nr+(ruvr-.5)*it;
    float ns=noise(vec2(ang,it*ruvr),nr);
    vec3 cex = c + .1
    		* ns/length(uvr)
			* hsv(vec3(1.,.5,1.2))
			* step(length(uvr), mix(.35, .45, ruvr));
    c = mix(c, cex, tRays);

    // Ear size
    vec2 rext = vec2(.3, .8);
    vec2 rint = rext - .2;

    // Fluffy management
    float fluffyL = (1 + sin(it * fluffyPeriod - fluffyPeriod * .5)) * fluffynessLR;
    float fluffyH = (1 + sin(it * fluffyPeriod)) * fluffynessH;
    float fluffyR = (1 + sin(it * fluffyPeriod + fluffyPeriod * .5)) * fluffynessLR;

    // right ear - ellipsoid inner + outer
    float angle = 0.5 + (0.035 + 0.05 * cos(it + 1.));
    vec2 uvx = rot(angle) * uv;
    uvx *= 4.0;
    uvx += vec2(-0.2, -0.7) * tAppearR;
    float d = sdEllipsoid(uvx, rint * tAppearR);
    float r = step(d, 0.);
    c = mix(c, earColor, r * tAppearR);
    d = max(sdEllipsoid(uvx, rext * tAppearR), -d);
    r = smoothstep(.01 + fluffyL, .0, d);
    c = mix(c, rabbitColor, r);

    // left ear - ellipsoid inner + outer
    angle = 0.37 + (0.05 + 0.05 * sin(it * 1.05));
    uvx = uv * rot(angle);
    uvx *= 4.0;
    uvx += vec2(0.2, -0.7) * tAppearL;
    d = sdEllipsoid(uvx, rint * tAppearL);
    r = step(d, 0.);
    c = mix(c, earColor, r * tAppearL);
    d = max(sdEllipsoid(uvx, rext * tAppearL), -d);
    r = smoothstep(.01 + fluffyR, .0, d);
    c = mix(c, rabbitColor, r);

    // head - circle
    uvx = uv * 10.0 / tAppearH;
    uvx += rabbitPan;
    uvx *= rot(it * 4);
    float amplitude = .1 * tshakeH;
    d = sdEllipsoid(uvx, headSize * vec2(
    		1 + amplitude * cos(it * shakeAmpSpeed),
			1 + amplitude * sin(it * shakeAmpSpeed)
    ));
    r = smoothstep(.32 + fluffyH * tFluffyH, .30, d); // [0., 1.]
    c = mix(c, rabbitColor, r);

    // Fade out
    c = mix(c, black, tFadeOut);

    // return
	fragColor = vec4(c, 1.);
}

    // alternative way to make an ear - rebased circle
    /*vec2 uvO = uv;
    uvO *= rot(0.5);
    uvO.x *= 3.;
    uvO *= 1.5;
    uvO.y -= 0.28;
    uvO.x += 0.29;
    float d = length(uvO);
    float r = smoothstep(.31, .30, d); // [0., 1.]
    c = mix(c, vec3(1.0, 0.79, 0.89), r);*/

void main() {
	vec4 color;
	mainImage(color, gl_FragCoord.xy);

	color.w = 1.0;
	gl_FragColor = color;
}
